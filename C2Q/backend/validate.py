"""
Validation framework for C2Q quantum circuits.

This module provides simulation and validation capabilities for quantum circuits
generated by the C2Q compiler. The primary function, validate_circuit(), validates
the output of a compiled quantum circuit against expected results without rebuilding
the circuit, ensuring consistency between visualization and validation.
"""

from typing import Dict, Optional

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator


def validate_circuit(
    circuit: QuantumCircuit,
    expected_result: int,
    verbose: bool = True,
    signed: bool = False,
    result_width: int = 8,
) -> bool:
    """
    Validate a quantum circuit by simulating it and checking the result.

    This function validates the exact circuit created by the compiler without
    regenerating it, ensuring the validated circuit matches what was visualized.

    Args:
        circuit: The Qiskit QuantumCircuit to validate (already created)
        expected_result: Expected integer result
        verbose: Whether to print detailed output
        signed: Whether to interpret result as signed two's complement (default: False)
        result_width: Number of bits in the result register (default: 8)

    Returns:
        True if validation passes, False otherwise
    """
    try:
        # simulate the circuit
        if verbose:
            print(f"[INFO] simulating the generated circuit...")
            print(
                f"   circuit has {circuit.num_qubits} qubits, {circuit.depth()} depth, {len(circuit)} gates"
            )

        counts = simulate_circuit(circuit, shots=1024)

        # extract result
        actual_result = extract_result_value(
            counts, target_width=result_width, signed=signed
        )

        if verbose:
            print(f"\n[INFO] results:")
            print(f"   expected: {expected_result}")
            print(f"   actual:   {actual_result}")

            # show measurement distribution
            print(f"\n[INFO] measurement distribution (top 5):")
            sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)[:5]
            for bits, count in sorted_counts:
                print(
                    f"   {bits}: {count} times ({count/sum(counts.values())*100:.1f}%)"
                )

        # validate
        passed = actual_result == expected_result

        if verbose:
            if passed:
                print(f"\n[PASS] circuit produces correct result!")
            else:
                print(f"\n[FAIL] expected {expected_result}, got {actual_result}")

        return passed

    except Exception as e:
        if verbose:
            print(f"\n[ERROR] during validation: {e}")
            import traceback

            traceback.print_exc()
        return False


def simulate_circuit(circuit: QuantumCircuit, shots: int = 1024) -> Dict[str, int]:
    """
    Simulate quantum circuit using matrix product state method.

    Uses Qiskit Aer's matrix_product_state simulator, which is efficient
    for circuits with localized entanglement typical of Draper arithmetic.
    Falls back to automatic method if MPS fails.

    Args:
        circuit: Qiskit quantum circuit to simulate
        shots: Number of simulation shots (default: 1024)

    Returns:
        Dictionary mapping measurement bitstrings to occurrence counts
    """
    # create a copy and add measurements if needed
    sim_circuit = circuit.copy()
    if sim_circuit.num_clbits == 0:
        sim_circuit.measure_all()

    # use matrix_product_state
    try:
        simulator = AerSimulator(method="matrix_product_state")
        job = simulator.run(sim_circuit, shots=shots, seed_simulator=42)
        result = job.result()
        return result.get_counts()
    except Exception as e:
        # fallback to automatic method -- MAY HANG OR FAIL ON LARGE CIRCUITS ---
        print(f"[WARN] MPS simulation failed, using automatic method: {e}")
        simulator = AerSimulator(method="automatic")
        job = simulator.run(sim_circuit, shots=shots, seed_simulator=42)
        result = job.result()
        return result.get_counts()


def extract_result_value(
    counts: Dict[str, int], target_width: int = 8, signed: bool = False
) -> Optional[int]:
    """
    Extract integer value from quantum measurement results.

    Interprets Qiskit measurement bitstrings according to qubit ordering conventions:
    - Bitstring format: \"qN...q2 q1 q0\" (leftmost is MSB, rightmost is LSB)
    - Result register is always in the LEFTMOST target_width bits
      (since Qiskit orders as q_last...q_first, and result is created last)

    Args:
        counts: Measurement results from simulation
        target_width: Number of bits in the result register (default: 8)
        signed: If True, interpret as two's complement signed integer (default: False)

    Returns:
        Integer value extracted from most common measurement outcome

    Example:
        For unsigned: '00000011' -> 3
        For signed 8-bit: '11111111' -> -1 (not 255)
    """
    if not counts:
        return None

    # get the most common measurement outcome
    most_common = max(counts.items(), key=lambda x: x[1])[0]

    # remove spaces from bitstring
    bitstring = most_common.replace(" ", "")

    # extract the leftmost target_width bits (result register is created last)
    result_bits = bitstring[:target_width]

    # convert to integer
    unsigned_value = int(result_bits, 2)

    # handle signed two's complement if requested
    if signed:
        # check if the sign bit (MSB) is set
        sign_bit = int(result_bits[0])
        if sign_bit == 1:
            # negative number: compute two's complement
            # formula: value - 2^n where n is the bit width
            signed_value = unsigned_value - (1 << target_width)
            return signed_value
        else:
            return unsigned_value
    else:
        return unsigned_value
