"""
Validation framework for C2Q quantum circuits.

This module provides simulation and validation capabilities for quantum circuits
generated by the C2Q compiler. The primary function, validate_circuit(), validates
the output of a compiled quantum circuit against expected results without rebuilding
the circuit, ensuring consistency between visualization and validation.
"""

from typing import Dict, Optional

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator


def validate_circuit(circuit: QuantumCircuit, expected_result: int, verbose: bool = True) -> bool:
    """
    Validate a quantum circuit by simulating it and checking the result.
    
    This function validates the exact circuit created by the compiler without
    regenerating it, ensuring the validated circuit matches what was visualized.
    
    Args:
        circuit: The Qiskit QuantumCircuit to validate (already created)
        expected_result: Expected integer result
        verbose: Whether to print detailed output
        
    Returns:
        True if validation passes, False otherwise
    """
    try:
        # Simulate the circuit
        if verbose:
            print(f"ğŸ”¬ Simulating the generated circuit...")
            print(f"   Circuit has {circuit.num_qubits} qubits, {circuit.depth()} depth, {len(circuit)} gates")
        
        counts = simulate_circuit(circuit, shots=1024)
        
        # Extract result
        actual_result = extract_result_value(counts, num_qubits=8)
        
        if verbose:
            print(f"\nğŸ“Š Results:")
            print(f"   Expected: {expected_result}")
            print(f"   Actual:   {actual_result}")
            
            # Show measurement distribution
            print(f"\nğŸ“ˆ Measurement distribution (top 5):")
            sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)[:5]
            for bits, count in sorted_counts:
                print(f"   {bits}: {count} times ({count/sum(counts.values())*100:.1f}%)")
        
        # Validate
        passed = (actual_result == expected_result)
        
        if verbose:
            if passed:
                print(f"\nâœ… PASSED: Circuit produces correct result!")
            else:
                print(f"\nâŒ FAILED: Expected {expected_result}, got {actual_result}")
        
        return passed
        
    except Exception as e:
        if verbose:
            print(f"\nâŒ ERROR during validation: {e}")
            import traceback
            traceback.print_exc()
        return False


def simulate_circuit(circuit: QuantumCircuit, shots: int = 1024) -> Dict[str, int]:
    """
    Simulate quantum circuit using matrix product state method.
    
    Uses Qiskit Aer's matrix_product_state simulator, which is efficient
    for circuits with localized entanglement typical of Draper arithmetic.
    Falls back to automatic method if MPS fails.
    
    Args:
        circuit: Qiskit quantum circuit to simulate
        shots: Number of simulation shots (default: 1024)
        
    Returns:
        Dictionary mapping measurement bitstrings to occurrence counts
    """
    # Create a copy and add measurements if needed
    sim_circuit = circuit.copy()
    if sim_circuit.num_clbits == 0:
        sim_circuit.measure_all()
    
    # Use matrix_product_state for efficiency with QFT circuits
    try:
        simulator = AerSimulator(method='matrix_product_state')
        job = simulator.run(sim_circuit, shots=shots, seed_simulator=42)
        result = job.result()
        return result.get_counts()
    except Exception as e:
        # Fallback to automatic method
        print(f"âš ï¸  MPS simulation failed, using automatic method: {e}")
        simulator = AerSimulator(method='automatic')
        job = simulator.run(sim_circuit, shots=shots, seed_simulator=42)
        result = job.result()
        return result.get_counts()


def extract_result_value(counts: Dict[str, int], num_qubits: int = 8) -> Optional[int]:
    """
    Extract integer value from quantum measurement results.
    
    Interprets Qiskit measurement bitstrings according to qubit ordering conventions:
    - Bitstring format: \"qN...q2 q1 q0\" (leftmost is MSB, rightmost is LSB)
    - For single register: entire bitstring represents the value
    - For multiple registers: rightmost num_qubits bits represent first register
    
    Example: 
        Measurement \"00000011\" represents value 3 (bits 0 and 1 set)
        
    Args:
        counts: Measurement results from simulation
        num_qubits: Number of qubits per register (default: 8)
        
    Returns:
        Integer value extracted from most common measurement outcome
    """
    if not counts:
        return None
    
    # Get the most common measurement outcome
    most_common = max(counts.items(), key=lambda x: x[1])[0]
    
    # Remove spaces from bitstring
    bitstring = most_common.replace(' ', '')
    
    print(f"\nğŸ” DEBUG: Full bitstring: {bitstring} (length: {len(bitstring)})")
    print(f"ğŸ” DEBUG: First 8 bits:  {bitstring[:8]}")
    print(f"ğŸ” DEBUG: Middle 8 bits: {bitstring[8:16]}")
    print(f"ğŸ” DEBUG: Last 8 bits:   {bitstring[16:24]}")
    
    # Extract relevant bits
    # In Qiskit, the measurement bitstring is "qN...q1q0" where rightmost = q0
    # The bitstring format: [last_register][middle_register][first_register]
    # For our case: [q2_result][q1_b][q0_a]
    # We want the RIGHTMOST register (first one created = q0? or q2?)
    
    # Let's try different interpretations:
    leftmost_8 = bitstring[:num_qubits]
    middle_8 = bitstring[num_qubits:2*num_qubits] if len(bitstring) >= 2*num_qubits else ""
    rightmost_8 = bitstring[-num_qubits:] if len(bitstring) > num_qubits else bitstring
    
    print(f"ğŸ” DEBUG: Leftmost 8  = {leftmost_8} -> int = {int(leftmost_8, 2)}")
    if middle_8:
        print(f"ğŸ” DEBUG: Middle 8    = {middle_8} -> int = {int(middle_8, 2)}")
    print(f"ğŸ” DEBUG: Rightmost 8 = {rightmost_8} -> int = {int(rightmost_8, 2)}")
    
    # The result register is the leftmost (last created register q2)
    # With do_swaps=False in QFT, there are NO explicit SWAP gates
    # So we read the bits in normal order (NO reversal needed)
    result_bits = leftmost_8
    
    print(f"ğŸ” DEBUG: Using leftmost (no reversal): {result_bits} = {int(result_bits, 2)}")
    
    return int(result_bits, 2)
